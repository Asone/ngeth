{"version":3,"file":"ngeth-contract.js.map","sources":["ng://@ngeth/contract/lib/contract.ts","ng://@ngeth/contract/lib/contract.module.ts","ng://@ngeth/contract/lib/abi/utils.ts","ng://@ngeth/contract/lib/abi/decoder.ts","ng://@ngeth/contract/lib/abi/encoder.ts","ng://@ngeth/contract/lib/contract.decorator.ts","ng://@ngeth/contract/lib/abi/encoder-test/encoder-test.contract.ts","ng://@ngeth/contract/lib/abi/test-event/test-event.contract.ts"],"sourcesContent":["import { ABIDefinition, toChecksumAddress, ContractModel, ITxObject } from '@ngeth/utils';\r\nimport { ContractProvider } from '@ngeth/provider';\r\nimport { ABIEncoder, ABIDecoder } from './abi';\r\n\r\nimport { Observable, forkJoin } from 'rxjs';\r\nimport { map,  switchMap } from 'rxjs/operators';\r\n\r\nexport class ContractClass<T extends ContractModel> {\r\n  public calls: { [P in keyof T['calls']]: T['calls'][P]; } = {} as any;\r\n  public sends: { [P in keyof T['sends']]: T['sends'][P]; } = {} as any;\r\n  public events: { [P in keyof T['events']]: T['events'][P]; } = {} as any;\r\n\r\n  constructor(\r\n    protected encoder: ABIEncoder,\r\n    protected decoder: ABIDecoder,\r\n    protected provider: ContractProvider,\r\n    private abi: ABIDefinition[],\r\n    public address?: string\r\n  ) {\r\n    if (!this.abi) { throw new Error('Please add an abi to the contract'); }\r\n    if (this.address) { this.address = toChecksumAddress(address); }\r\n    const calls: any[] = [];\r\n    const sends: any[] = [];\r\n    const events: any[] = [];\r\n    for (const def of this.abi) {\r\n      if (def.type === 'function' && def.constant === true) {\r\n        calls.push(def);\r\n      }\r\n      if (def.type === 'function' && def.constant === false) {\r\n        sends.push(def);\r\n      }\r\n      if (def.type === 'event') {\r\n        events.push(def);\r\n      }\r\n    }\r\n    calls.forEach(def => (this.calls[def.name] = this.callMethod.bind(this, def)));\r\n    sends.forEach(def => (this.sends[def.name] = this.sendMethod.bind(this, def)));\r\n    events.forEach(def => (this.events[def.name] = this.eventMethod.bind(this, def)));\r\n  }\r\n\r\n  /**\r\n   * Deploy the contract on the blockchain\r\n   * @param bytes The bytes of the contract\r\n   * @param params Params to pass into the constructor\r\n   */\r\n  public deploy(bytes: string, ...params: any[]) {\r\n    const constructor = this.abi.find(def => def.type === 'constructor');\r\n    const noParam = params.length === 0;\r\n    const data = noParam ? bytes : this.encoder.encodeConstructor(constructor, bytes, params);\r\n    return this.fillGas({ ...this.provider.defaultTx, data })\r\n      .pipe(switchMap(tx => this.provider.sendTransaction(tx)));\r\n  }\r\n\r\n  /**\r\n   * Used for 'call' methods\r\n   * @param method The method to call\r\n   * @param params The params given by the user\r\n   */\r\n  private callMethod(method: ABIDefinition, ...params: any[]) {\r\n    const data = this.encoder.encodeMethod(method, params);\r\n    return this.provider\r\n      .call<string>(this.address, data)\r\n      .pipe(\r\n        map(result => this.decoder.decodeOutputs(result, method.outputs)),\r\n        map(result => result[Object.keys(result)[0]])\r\n      );\r\n  }\r\n\r\n  /**\r\n   * Used for 'send' methods\r\n   * @param method The method to send\r\n   * @param params The params given by the user\r\n   */\r\n  private sendMethod(method: ABIDefinition, ...params: any[]) {\r\n    const { to, data } = { to: this.address, data: this.encoder.encodeMethod(method, params) };\r\n    return this.fillGas({ ...this.provider.defaultTx, to, data })\r\n      .pipe(switchMap(tx => this.provider.sendTransaction(tx)));\r\n  }\r\n\r\n  /**\r\n   * Used for 'event' definition\r\n   * @param event The event definition in the ABI\r\n   */\r\n  private eventMethod(event: ABIDefinition) {\r\n    const topics = this.encoder.encodeEvent(event);\r\n    return this.provider.event(this.address, [topics]).pipe(\r\n      map(logs => this.decoder.decodeEvent(logs.topics, logs.data, event.inputs))\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Fill the estimated amount of gas and gasPrice to use for a transaction\r\n   * @param tx The raw transaction to estimate the gas from\r\n   */\r\n  private fillGas(tx: Partial<ITxObject>): Observable<Partial<ITxObject>> {\r\n    return forkJoin(\r\n      this.provider.estimateGas(tx),\r\n      this.provider.gasPrice()\r\n    ).pipe(map(([gas, gasPrice]) => {\r\n        return { ...tx, gas, gasPrice }\r\n      })\r\n    );\r\n  }\r\n\r\n}\r\n","import { NgModule } from '@angular/core';\r\n\r\n@NgModule()\r\nexport class ContractModule {}\r\n","import { ABIInput } from '@ngeth/utils';\r\n\r\n/**\r\n * Create an array of params based on the size of the array in the ABI and the model\r\n * @param size The amount of elements in the array\r\n * @param param The model of param to based the new array on\r\n */\r\nexport function paramFromArray(size: number, param: ABIInput) {\r\n  const type = nestedType(param.type);\r\n  const paramModel = { ...param, name: '', type: type };  // Remove name to avoid conflict\r\n  return Array(size).fill(paramModel);\r\n}\r\n\r\n/**\r\n * Return the size of the fixed array ask by the ABI\r\n * @param type The type of the array\r\n */\r\nexport function fixedArraySize(type: string): number {\r\n  const lastArrayStr = nestedArray(type).pop();\r\n  const lastArray = JSON.parse(lastArrayStr);\r\n  if (lastArray.length === 0) {\r\n    throw new Error(`Array of type ${type} is not a fixed array`);\r\n  }\r\n  return parseInt(lastArray[0], 10);\r\n}\r\n\r\n/**\r\n * Check if the tuple is static\r\n * @param tuple The tuple object\r\n */\r\nexport function isStaticTuple(tuple: ABIInput): boolean {\r\n  return (\r\n    tuple.type === 'tuple'  // Prevent type to be 'tuple[]'\r\n    && tuple.components\r\n    && tuple.components.filter(param => !isStatic(param)).length === 0\r\n  );\r\n}\r\n\r\n/**\r\n * Check if the array is static\r\n * @param arr The array object\r\n */\r\nexport function isStaticArray(arr: ABIInput): boolean {\r\n  return (\r\n    isFixedArray(arr.type)\r\n    && isStatic({...arr, type: nestedType(arr.type)}) // Nested Type is static\r\n  );\r\n}\r\n\r\n/**\r\n * Check if the output is static\r\n * @param output The output defined in the abi\r\n */\r\nexport function isStatic(output: ABIInput): boolean {\r\n  const type = output.type;\r\n  switch (true) {\r\n    // Array\r\n    case /\\[([0-9]*)\\]/.test(type):\r\n      return isStaticArray(output);\r\n    // Tuple\r\n    case /tuple?/.test(type): {\r\n      return isStaticTuple(output);\r\n    }\r\n    // Dynamic\r\n    case /string?/.test(type):\r\n    case /bytes?\\b/.test(type):\r\n      return false;\r\n    // Static\r\n    case /bytes?/.test(type):\r\n    case /int?/.test(type):\r\n    case /address?/.test(type):\r\n    case /bool?/.test(type):\r\n      return true;\r\n  }\r\n  return true;\r\n}\r\n\r\n/**\r\n * Check if the array is fixed\r\n * @param type Type of the array\r\n */\r\nexport function isFixedArray(type: string) {\r\n  return /\\[[0-9]\\]/.test(type);\r\n}\r\n\r\n/**\r\n * Remove last [] in type\r\n * @example int[32] => int\r\n * @example int[2][3] => int[2]\r\n * @param type The type to modify\r\n */\r\nexport function nestedType(type: string): string {\r\n  const arrays = nestedArray(type);\r\n  if (!arrays) { return type; }\r\n  const lastArray = arrays[arrays.length - 1];\r\n  return type.substring(0, type.length - lastArray.length);\r\n}\r\n\r\n/**\r\n * Should return array of nested types\r\n * @example int[2][3][] => [[2], [3], []]\r\n * @example int[] => [[]]\r\n * @example int => null\r\n * @param type The type to match\r\n */\r\nexport function nestedArray(type: string): string[] {\r\n  return type.match(/(\\[[0-9]*\\])/g);\r\n}\r\n\r\n","import { BN } from 'bn.js';\r\nimport { Injectable } from '@angular/core';\r\nimport { ContractModule } from './../contract.module';\r\nimport {\r\n  isStatic,\r\n  isFixedArray,\r\n  fixedArraySize,\r\n  paramFromArray,\r\n  isStaticTuple,\r\n  isStaticArray } from './utils';\r\nimport {\r\n  ABIOutput,\r\n  ABIInput,\r\n  hexToNumber,\r\n  hexToUtf8,\r\n  hexToNumberString,\r\n  toChecksumAddress\r\n} from '@ngeth/utils';\r\n\r\nexport class DecodedParam {\r\n  constructor(public result: DecodedParam, public offset: number) {}\r\n}\r\n\r\n@Injectable({ providedIn: ContractModule })\r\nexport class ABIDecoder {\r\n\r\n  /**\r\n   * Decode an event output\r\n   * @param topics The topics of the logs (indexed values)\r\n   * @param data The data of the logs (bytes)\r\n   * @param inputs The inputs givent by the ABI\r\n   */\r\n  public decodeEvent(topics: string[], data: string, inputs: ABIInput[]): any {\r\n    const outputs = this.decodeOutputs(data, inputs);\r\n    inputs\r\n      .filter(input => input.indexed)\r\n      .forEach((input, i) => {\r\n        const topic = topics[i + 1].replace('0x', '');\r\n        // If indexed value is static decode, else return as it\r\n        outputs[input.name] = isStatic(input) ? this.decodeBytes(topic, input) : topic;\r\n      });\r\n    return outputs;\r\n  }\r\n\r\n  /**\r\n   * Remap the bytes to decode depending on its type\r\n   * @param bytes The bytes to decode\r\n   * @param output The output described in the Abi\r\n   */\r\n  public decodeBytes(bytes: string, output: ABIOutput) {\r\n    const type = output.type;\r\n    // Compare true with the result of the cases\r\n    switch (true) {\r\n      // Array: Must be first\r\n      case /\\[([0-9]*)\\]/.test(type):\r\n        return this.decodeArray(bytes, output);\r\n      // Tuple\r\n      case /tuple?/.test(type):\r\n        return this.decodeTuple(bytes, output.components);\r\n      // String\r\n      case /string?/.test(type):\r\n        return this.decodeString(bytes);\r\n      // Dynamic Bytes\r\n      case /bytes?\\b/.test(type):\r\n        return this.decodeDynamicBytes(bytes);\r\n      // Bytes\r\n      case /bytes?/.test(type):\r\n        return this.decodeStaticBytes(bytes);\r\n      // Bytes\r\n      case /int?/.test(type):\r\n        return this.decodeInt(bytes);\r\n      // Address\r\n      case /address?/.test(type):\r\n        return this.decodeAddress(bytes);\r\n      // Bool\r\n      case /bool?/.test(type):\r\n        return this.decodeBool(bytes);\r\n      default: {\r\n        throw new Error('Cannot find the decoder for the type : ' + type);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Decode the outputs : Start from the last to the first (to know the length of the tail)\r\n   * @param bytes The bytes of the outputs\r\n   * @param outputs The outputs from the abi\r\n   */\r\n  public decodeOutputs(bytes: string, outputs: (ABIOutput | ABIInput)[]): any {\r\n    bytes = bytes.replace('0x', '');\r\n    const init = { result: {}, offset: bytes.length };\r\n    return outputs\r\n      .filter(output => !(<ABIInput>output).indexed) // Remove indexed values\r\n      .reduceRight((acc: DecodedParam, output: ABIOutput, i: number) => {\r\n        const head = this.getHead(bytes, outputs, i);\r\n        if (isStatic(output)) {\r\n          acc.result[output.name || i] = this.decodeBytes(head, output);\r\n          return new DecodedParam(acc.result, acc.offset);\r\n        } else {\r\n          const tailStart = hexToNumber(head) * 2; // transform bytes to hex\r\n          const tailEnd = acc.offset;\r\n          const tail = bytes.substring(tailStart, tailEnd);\r\n          acc.result[output.name || i] = this.decodeBytes(tail, output);\r\n          return new DecodedParam(acc.result, tailStart);\r\n        }\r\n      }, init\r\n    ).result;\r\n  }\r\n\r\n  /**\r\n   * Decode a array\r\n   * @param bytes The bytes of this array\r\n   * @param output The output object defined in the abi\r\n   */\r\n  public decodeArray(bytes: string, output: ABIOutput): any[] {\r\n    let amount: number;\r\n    if (isFixedArray(output.type)) {\r\n      amount = fixedArraySize(output.type);\r\n    } else {\r\n      amount = hexToNumber(bytes.slice(0, 64));\r\n    }\r\n    const nestedBytes = isFixedArray(output.type) ? bytes : bytes.slice(64);\r\n    const outputArray = paramFromArray(amount, output);\r\n    const decoded = this.decodeOutputs(nestedBytes, outputArray);\r\n    return Object.keys(decoded).map(key => decoded[key]);\r\n  }\r\n\r\n  /** Decode a tuple */\r\n  public decodeTuple(bytes: string, outputs: ABIOutput[]): any {\r\n    return this.decodeOutputs(bytes, outputs);\r\n  }\r\n\r\n  /** Decode a string */\r\n  public decodeString(bytes: string): string {\r\n    const str = bytes.slice(64);\r\n    return hexToUtf8(str);\r\n  }\r\n\r\n  /** Decode a dynamic byte */\r\n  public decodeDynamicBytes(bytes: string): string {\r\n    const amount = hexToNumber(bytes.slice(0, 64));\r\n    return bytes.slice(64).substring(0, amount * 2);\r\n  }\r\n\r\n  /** Decode a static byte */\r\n  public decodeStaticBytes(bytes: string) {\r\n    return bytes.replace(/\\b0+(0+)/, '');\r\n  }\r\n\r\n  /**\r\n   * Decode a uint or int\r\n   * WARNING : Return a string\r\n   */\r\n  public decodeInt(bytes: string): string {\r\n    const isNegative = (value: string) => {\r\n      return (new BN(value.substr(0, 1), 16).toString(2).substr(0, 1)) === '1';\r\n    }\r\n    if (isNegative(bytes)) {\r\n      return new BN(bytes, 16).fromTwos(256).toString(10);\r\n    }\r\n    return hexToNumberString(bytes);\r\n  }\r\n\r\n  /** Decode an address */\r\n  public decodeAddress(bytes: string): string {\r\n    return toChecksumAddress(bytes.substring(24));\r\n  }\r\n\r\n  /** Decode a boolean */\r\n  public decodeBool(bytes: string): boolean {\r\n    const last = bytes.substring(63);\r\n    return last === '1' ? true : false;\r\n  }\r\n\r\n  /******\r\n   * HEAD\r\n   ******/\r\n\r\n  /**\r\n   * Return the head part of the output\r\n   * @param bytes The bytes of the outputS\r\n   * @param outputs The list of outputs\r\n   * @param index The index of the output to check in the outputs\r\n   */\r\n  private getHead(bytes: string, outputs: ABIOutput[], index: number): string {\r\n    let offset = 0;\r\n    for (let i = 0; i < index; i++) {\r\n      if (isStaticTuple(outputs[i])) {\r\n        const head = this.getAllHeads(bytes.substr(offset), outputs[i].components);\r\n        offset += head.length;\r\n      } else if (isStaticArray(outputs[i])) {\r\n        offset += this.staticArraySize(bytes.substr(offset), outputs[index]);\r\n      } else {\r\n        offset += 64;\r\n      }\r\n    }\r\n    if (isStaticTuple(outputs[index])) {\r\n      const length = this.getAllHeads(bytes.substr(offset), outputs[index].components).length\r\n      return bytes.substr(offset, length);\r\n    } else if(isStaticArray(outputs[index])) {\r\n      const length = this.staticArraySize(bytes.substr(offset), outputs[index]);\r\n      return bytes.substr(offset, length);\r\n    } else {\r\n      return bytes.substr(offset, 64);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the size of a static array\r\n   * @param bytes Bytes starting at the beginning of the array\r\n   * @param output The array model\r\n   */\r\n  private staticArraySize(bytes: string, output: ABIOutput) {\r\n    const size = fixedArraySize(output.type);\r\n    const outputArray = paramFromArray(size, output);\r\n    return this.getAllHeads(bytes, outputArray).length;\r\n  }\r\n\r\n  /**\r\n   * Get all heads from static arrays or tuples\r\n   * @param bytes Bytes starting at the beginning of the array or tuple\r\n   * @param outputs The outputs given by the ABI for this array or tuple\r\n   */\r\n  private getAllHeads(bytes: string, outputs: ABIOutput[]) {\r\n    return outputs.reduceRight((acc: string, output: ABIOutput, i: number) => {\r\n        return acc + this.getHead(bytes, outputs, i);\r\n      },'');\r\n  }\r\n\r\n}\r\n","import { Injectable } from '@angular/core';\r\nimport { ABIInput, numberToHex, utf8ToHex, toBN, ABIDefinition, keccak256 } from '@ngeth/utils';\r\nimport { ContractModule } from '../contract.module';\r\nimport { isStatic, isFixedArray, paramFromArray, fixedArraySize } from './utils';\r\n\r\nexport class EncodedParam {\r\n  constructor(public head: string = '', public tail = '') {}\r\n}\r\n\r\n@Injectable({ providedIn: ContractModule })\r\nexport class ABIEncoder {\r\n  constructor() {}\r\n\r\n  /**\r\n   * Encode the constructor method for deploying\r\n   * @param constructor The constructor param defined in the ABI\r\n   * @param bytes The content of the contract\r\n   * @param args The arguments to pass into the constructor if any\r\n   */\r\n  public encodeConstructor(\r\n    constructor: ABIDefinition,\r\n    bytes: string,\r\n    args?: any[]\r\n  ) {\r\n    const encoded = this.encodeInputs(args, constructor.inputs);\r\n    return bytes + encoded.head + encoded.tail;\r\n  }\r\n\r\n  /**\r\n   * Encode the whole method\r\n   * @param mehtod The method the encode has defined in the ABI\r\n   * @param args The list of arguments given by the user\r\n   */\r\n  public encodeMethod(method: ABIDefinition, args: any[]) {\r\n    // Create and sign method\r\n    const { name, inputs } = method;\r\n    const signature = this.signMethod(method);\r\n    const hashSign = keccak256(signature).slice(0, 10);\r\n\r\n    // Create the encoded arguments\r\n    const encoded = this.encodeInputs(args, inputs);\r\n    return hashSign + encoded.head + encoded.tail;\r\n  }\r\n\r\n  /**\r\n   * Encode an event\r\n   * @param event The event to encode\r\n   */\r\n  public encodeEvent(event: ABIDefinition): string {\r\n    const { name, inputs } = event;\r\n    const signature = this.signMethod(event);\r\n    return keccak256(signature);\r\n  }\r\n\r\n  /*******************************************\r\n   *************** SIGNATURE *****************\r\n   *******************************************/\r\n\r\n  /**\r\n   * Create a string for the signature based on the params in the ABI\r\n   * @param params The params given by the ABI.\r\n   */\r\n  private signInputs(inputs: ABIInput[]): string {\r\n    return inputs\r\n      .map(input => input.components ? this.tupleType(input) : input.type)\r\n      .join(',');\r\n  }\r\n\r\n  /** Return the type of a tuple needed for the signature */\r\n  private tupleType(tuple: ABIInput): string {\r\n    const innerTypes = this.signInputs(tuple.components);\r\n    const arrayPart = tuple.type.substr(5);\r\n    return `(${innerTypes})${arrayPart}`;\r\n  }\r\n\r\n  /**\r\n   * Sign a specific method based on the ABI\r\n   * @param mehtod The method the encode has defined in the ABI\r\n   */\r\n  private signMethod(method: ABIDefinition): string {\r\n    const { name, inputs } = method;\r\n    const types = this.signInputs(inputs);\r\n    return `${name}(${types})`;\r\n  }\r\n\r\n  /*******************************************\r\n   **************** ENCODE *******************\r\n   *******************************************/\r\n\r\n  /**\r\n   * Map to the right encoder depending on the type\r\n   * @param arg the arg of the input\r\n   * @param input the input defined in the ABI\r\n   */\r\n  public encode(arg: any, input: ABIInput): string {\r\n    const type = input.type;\r\n    // Compare true with the result of the cases\r\n    switch (true) {\r\n      // Array: Must be first\r\n      case /\\[([0-9]*)\\]/.test(type): {\r\n        return this.encodeArray(arg, input);\r\n      }\r\n      // Tuple\r\n      case /tuple?/.test(type): {\r\n        // Get args given as an object\r\n        const args = Object.keys(arg).map(key => arg[key]);\r\n        return this.encodeTuple(args, input.components);\r\n      }\r\n      // String\r\n      case /string?/.test(type): {\r\n        return this.encodeString(arg);\r\n      }\r\n      // Dynamic Bytes\r\n      case /bytes?\\b/.test(type): {\r\n        return this.encodeDynamicBytes(arg);\r\n      }\r\n      // Static Bytes\r\n      case /bytes?/.test(type): {\r\n        return this.encodeStaticBytes(arg);\r\n      }\r\n      // Int / Uint\r\n      case /int?/.test(type): {\r\n        return this.encodeInt(arg, input);\r\n      }\r\n      // Address\r\n      case /address?/.test(type): {\r\n        return this.encodeAddress(arg);\r\n      }\r\n      // Bool\r\n      case /bool?/.test(type): {\r\n        return this.encodeBool(arg);\r\n      }\r\n      default: {\r\n        throw new Error('Cannot find the encoder for the type : ' + type);\r\n      }\r\n    }\r\n  }\r\n\r\n  /*******************\r\n   * STATIC OR DYNAMIC\r\n   *******************/\r\n\r\n  /**\r\n   * Encode a list of inputs\r\n   * @param args The arguments given by the users\r\n   * @param inputs The inputs defined in the ABI\r\n   */\r\n  public encodeInputs(args: any[], inputs: ABIInput[]): EncodedParam {\r\n    const offset = args.length * 64;\r\n    const init = new EncodedParam();\r\n    return inputs.reduce(\r\n      (prev: EncodedParam, input: ABIInput, i: number) => {\r\n        const encoded = this.encode(args[i], input)\r\n        const suboffset = (offset + prev.tail.length) / 2;\r\n        if (isStatic(input)) {\r\n          return new EncodedParam(prev.head + encoded, prev.tail);\r\n        } else {\r\n          let head = numberToHex(suboffset).replace('0x', '');\r\n          head = this.padStart(head, 64, '0');\r\n          return new EncodedParam(prev.head + head, prev.tail + encoded)\r\n        }\r\n      }, init\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Encode an array\r\n   * @param args The argument given by the user for this array\r\n   * @param input The input defined in the ABI\r\n   */\r\n  private encodeArray(args: any[], input: ABIInput): string {\r\n    if (args.length === 0) {\r\n      throw new Error(`No arguments found in array ${input.name}`);\r\n    }\r\n    let encoded = '';\r\n    if (!isFixedArray(input.type)) {\r\n      encoded = numberToHex(args.length).replace('0x', '')\r\n      encoded = this.padStart(encoded, 64, '0');\r\n    } else if (args.length !== fixedArraySize(input.type)) {\r\n      throw new Error(`${args} should be of size ${fixedArraySize(input.type)}`);\r\n    }\r\n    const inputs = paramFromArray(args.length, input);\r\n    const { head, tail } = this.encodeInputs(args, inputs);\r\n    return encoded + head + tail;\r\n  }\r\n\r\n  /**\r\n   * Encode the tuple\r\n   * @param args Arguments of this tuple\r\n   * @param inputs Inputs defined in the ABI\r\n   */\r\n  private encodeTuple(args: any[], inputs: ABIInput[]): string {\r\n    const { head, tail } = this.encodeInputs(args, inputs);\r\n    return head + tail;\r\n  }\r\n\r\n  /*********\r\n   * DYNAMIC\r\n   *********/\r\n\r\n  /** Encode a string */\r\n  private encodeString(arg: string): string {\r\n    if (typeof arg !== 'string') {\r\n      throw new Error(`Argument ${arg} should be a string`);\r\n    }\r\n    const hex = utf8ToHex(arg).replace('0x', '');\r\n    const size = numberToHex(arg.length).replace('0x', '')\r\n    const hexSize = hex.length + 64 - (hex.length % 64);\r\n    return this.padStart(size, 64, '0') + this.padStart(hex, hexSize, '0');\r\n  }\r\n\r\n  /**\r\n   * Encode a dynamic bytes\r\n   * @example bytes\r\n   */\r\n  private encodeDynamicBytes(arg: string) {\r\n    if (typeof arg !== 'string') {\r\n      throw new Error(`Argument ${arg} should be a string`);\r\n    }\r\n    const hex = arg.replace('0x', '');\r\n    const size = numberToHex(hex.length / 2).replace('0x', '');\r\n    const hexSize = hex.length + 64 - (hex.length % 64);\r\n    return this.padStart(size, 64, '0') + this.padEnd(hex, hexSize, '0');\r\n  }\r\n\r\n  /********\r\n   * STATIC\r\n   ********/\r\n\r\n  /**\r\n   * Encode a static bytes\r\n   * @example bytes3, bytes32\r\n   */\r\n  private encodeStaticBytes(arg: string | number) {\r\n    if (typeof arg !== 'string' && typeof arg !== 'number') {\r\n      throw new Error(`Argument ${arg} should be a string or number`);\r\n    }\r\n    if (typeof arg === 'number') { arg = arg.toString(16); }\r\n    const result = arg.replace('0x', '');\r\n    return this.padEnd(result, 46, '0');\r\n  }\r\n\r\n  /**\r\n   * Encode int or uint\r\n   * @example int, int32, uint256\r\n   */\r\n  private encodeInt(arg: number, input: ABIInput) {\r\n    if (typeof arg !== 'number') {\r\n      throw new Error(`Argument ${arg} should be a number`);\r\n    }\r\n    if (arg % 1 !== 0) {\r\n      throw new Error('Only provider integers, Solidity does not manage floats');\r\n    }\r\n    if (input.type.includes('uint') && arg < 0) {\r\n      throw new Error(`\"uint\" cannot be negative at value ${arg}`)\r\n    }\r\n    return toBN(arg).toTwos(256).toString(16, 64);\r\n  }\r\n\r\n  /** Encode an address */\r\n  private encodeAddress(arg: string | number) {\r\n    if (typeof arg !== 'string' && typeof arg !== 'number') {\r\n      throw new Error(`Argument ${arg} should be a string or number`);\r\n    }\r\n    if (typeof arg === 'number') { arg = arg.toString(16); }\r\n    const result = arg.replace('0x', '');\r\n    return this.padStart(result, 64, '0');\r\n  }\r\n\r\n  /** Encode a boolean */\r\n  private encodeBool(arg: boolean): string {\r\n    if (typeof arg !== 'boolean') {\r\n      throw new Error(`Argument ${arg} should be a boolean`);\r\n    }\r\n    return arg ? this.padStart('1', 64, '0') : this.padStart('0', 64, '0');\r\n  }\r\n\r\n  /***\r\n   * PadStart / PadEnd\r\n   */\r\n  private padStart(target: string, targetLength: number, padString: string): string {\r\n    /* tslint:disable */\r\n    targetLength = targetLength >> 0; //truncate if number or convert non-number to 0;\r\n    /* tslint:enable */\r\n    padString = String(typeof padString !== 'undefined' ? padString : ' ');\r\n    if (target.length > targetLength) {\r\n      return String(target);\r\n    } else {\r\n      targetLength = targetLength - target.length;\r\n      if (targetLength > padString.length) {\r\n        padString += padString.repeat(targetLength / padString.length); //append to original to ensure we are longer than needed\r\n      }\r\n      return padString.slice(0, targetLength) + String(target);\r\n    }\r\n  };\r\n\r\n  private padEnd(target: string, targetLength: number, padString: string): string{\r\n    /* tslint:disable */\r\n    targetLength = targetLength >> 0; //floor if number or convert non-number to 0;\r\n    /* tslint:enable */\r\n    padString = String(typeof padString !== 'undefined' ? padString : ' ');\r\n    if (target.length > targetLength) {\r\n      return String(target);\r\n    } else {\r\n      targetLength = targetLength - target.length;\r\n      if (targetLength > padString.length) {\r\n        padString += padString.repeat(targetLength / padString.length); //append to original to ensure we are longer than needed\r\n      }\r\n      return String(target) + padString.slice(0, targetLength);\r\n    }\r\n  };\r\n}\r\n","import { ContractModel } from '@ngeth/utils';\r\nimport { Injectable, Type } from '@angular/core';\r\nimport { ContractProvider } from '@ngeth/provider';\r\nimport { ABIEncoder, ABIDecoder } from './abi';\r\nimport { ContractModule } from './contract.module';\r\nimport { ContractClass } from './contract';\r\n\r\nexport function Contract<T extends ContractModel>(metadata: {\r\n  provider?: Type<ContractProvider>;  // TODO : Use for custom provider (with Auth)\r\n  abi: any[] | string;\r\n  addresses?: {\r\n    mainnet?: string;\r\n    ropsten?: string;\r\n    rinkeby?: string;\r\n    kovan?: string;\r\n  };\r\n}) {\r\n  const { abi, addresses } = metadata;\r\n  const jsonInterace: any[] = typeof abi === 'string' ? JSON.parse(abi) : abi;\r\n\r\n  /**\r\n   * Get the address of the contract depending on the id of the network\r\n   * @param id The id of the network\r\n   */\r\n  const getAddress = (id: number): string => {\r\n    switch(id) {\r\n      case 1: return addresses['mainnet'];\r\n      case 3: return addresses['ropsten'];\r\n      case 4: return addresses['rinkeby'];\r\n      case 42: return addresses['kovan'];\r\n      default: return addresses['mainnet'];\r\n    }\r\n  }\r\n\r\n  return function(Base) {\r\n    @Injectable({ providedIn: ContractModule })\r\n    class ContractDecorated extends ContractClass<T> {\r\n      constructor(\r\n        protected encoder: ABIEncoder,\r\n        protected decoder: ABIDecoder,\r\n        protected provider: ContractProvider\r\n      ) {\r\n        super(encoder, decoder, provider, jsonInterace, getAddress(provider.id));\r\n      }\r\n    }\r\n    return ContractDecorated as any;\r\n  };\r\n}\r\n","import { ContractClass } from '../../contract';\r\nimport { Contract } from '../../contract.decorator';\r\nimport { IEncoderTestContract } from './encoder-test.models';\r\nconst abi = require('./encoder-test.abi.json');\r\n\r\n@Contract<IEncoderTestContract>({\r\n  abi: abi,\r\n  addresses: {\r\n    ropsten: '0x344f641ff60f6308ad70b1e62052764835f48e00'\r\n  }\r\n})\r\nexport class EncoderTestContract extends ContractClass<IEncoderTestContract> {}\r\n","import { ContractClass } from '../../contract';\r\nimport { Contract,  } from '../../contract.decorator';\r\nimport { ITestEventContract } from './test-event.models';\r\nconst abi = require('./test-event.abi.json');\r\n\r\n@Contract<ITestEventContract>({\r\n  abi: abi,\r\n  addresses: {\r\n    ropsten: '0xc0D6C4cbA14aeFC218d0ff669e07D73E74078248'\r\n  }\r\n})\r\nexport class TestEventContract extends ContractClass<ITestEventContract> {}\r\n"],"names":["abi"],"mappings":"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"}
