{"version":3,"file":"ngeth-contract.umd.js.map","sources":[null,"ng://@ngeth/contract/lib/contract.ts","ng://@ngeth/contract/lib/contract.module.ts","ng://@ngeth/contract/lib/abi/utils.ts","ng://@ngeth/contract/lib/abi/decoder.ts","ng://@ngeth/contract/lib/abi/encoder.ts","ng://@ngeth/contract/lib/contract.decorator.ts","ng://@ngeth/contract/lib/abi/encoder-test/encoder-test.contract.ts","ng://@ngeth/contract/lib/abi/test-event/test-event.contract.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = Object.assign || function __assign(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n    }\r\n    return t;\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; }; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator];\r\n    return m ? m.call(o) : typeof __values === \"function\" ? __values(o) : o[Symbol.iterator]();\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { ABIDefinition, toChecksumAddress, ContractModel, ITxObject } from '@ngeth/utils';\r\nimport { ContractProvider } from '@ngeth/provider';\r\nimport { ABIEncoder, ABIDecoder } from './abi';\r\n\r\nimport { Observable, forkJoin } from 'rxjs';\r\nimport { map,  switchMap } from 'rxjs/operators';\r\n\r\nexport class ContractClass<T extends ContractModel> {\r\n  public calls: { [P in keyof T['calls']]: T['calls'][P]; } = {} as any;\r\n  public sends: { [P in keyof T['sends']]: T['sends'][P]; } = {} as any;\r\n  public events: { [P in keyof T['events']]: T['events'][P]; } = {} as any;\r\n\r\n  constructor(\r\n    protected encoder: ABIEncoder,\r\n    protected decoder: ABIDecoder,\r\n    protected provider: ContractProvider,\r\n    private abi: ABIDefinition[],\r\n    public address?: string\r\n  ) {\r\n    if (!this.abi) { throw new Error('Please add an abi to the contract'); }\r\n    if (this.address) { this.address = toChecksumAddress(address); }\r\n    const calls: any[] = [];\r\n    const sends: any[] = [];\r\n    const events: any[] = [];\r\n    for (const def of this.abi) {\r\n      if (def.type === 'function' && def.constant === true) {\r\n        calls.push(def);\r\n      }\r\n      if (def.type === 'function' && def.constant === false) {\r\n        sends.push(def);\r\n      }\r\n      if (def.type === 'event') {\r\n        events.push(def);\r\n      }\r\n    }\r\n    calls.forEach(def => (this.calls[def.name] = this.callMethod.bind(this, def)));\r\n    sends.forEach(def => (this.sends[def.name] = this.sendMethod.bind(this, def)));\r\n    events.forEach(def => (this.events[def.name] = this.eventMethod.bind(this, def)));\r\n  }\r\n\r\n  /**\r\n   * Deploy the contract on the blockchain\r\n   * @param bytes The bytes of the contract\r\n   * @param params Params to pass into the constructor\r\n   */\r\n  public deploy(bytes: string, ...params: any[]) {\r\n    const constructor = this.abi.find(def => def.type === 'constructor');\r\n    const noParam = params.length === 0;\r\n    const data = noParam ? bytes : this.encoder.encodeConstructor(constructor, bytes, params);\r\n    return this.fillGas({ ...this.provider.defaultTx, data })\r\n      .pipe(switchMap(tx => this.provider.sendTransaction(tx)));\r\n  }\r\n\r\n  /**\r\n   * Used for 'call' methods\r\n   * @param method The method to call\r\n   * @param params The params given by the user\r\n   */\r\n  private callMethod(method: ABIDefinition, ...params: any[]) {\r\n    const data = this.encoder.encodeMethod(method, params);\r\n    return this.provider\r\n      .call<string>(this.address, data)\r\n      .pipe(\r\n        map(result => this.decoder.decodeOutputs(result, method.outputs)),\r\n        map(result => result[Object.keys(result)[0]])\r\n      );\r\n  }\r\n\r\n  /**\r\n   * Used for 'send' methods\r\n   * @param method The method to send\r\n   * @param params The params given by the user\r\n   */\r\n  private sendMethod(method: ABIDefinition, ...params: any[]) {\r\n    const { to, data } = { to: this.address, data: this.encoder.encodeMethod(method, params) };\r\n    return this.fillGas({ ...this.provider.defaultTx, to, data })\r\n      .pipe(switchMap(tx => this.provider.sendTransaction(tx)));\r\n  }\r\n\r\n  /**\r\n   * Used for 'event' definition\r\n   * @param event The event definition in the ABI\r\n   */\r\n  private eventMethod(event: ABIDefinition) {\r\n    const topics = this.encoder.encodeEvent(event);\r\n    return this.provider.event(this.address, [topics]).pipe(\r\n      map(logs => this.decoder.decodeEvent(logs.topics, logs.data, event.inputs))\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Fill the estimated amount of gas and gasPrice to use for a transaction\r\n   * @param tx The raw transaction to estimate the gas from\r\n   */\r\n  private fillGas(tx: Partial<ITxObject>): Observable<Partial<ITxObject>> {\r\n    return forkJoin(\r\n      this.provider.estimateGas(tx),\r\n      this.provider.gasPrice()\r\n    ).pipe(map(([gas, gasPrice]) => {\r\n        return { ...tx, gas, gasPrice }\r\n      })\r\n    );\r\n  }\r\n\r\n}\r\n","import { NgModule } from '@angular/core';\r\n\r\n@NgModule()\r\nexport class ContractModule {}\r\n","import { ABIInput } from '@ngeth/utils';\r\n\r\n/**\r\n * Create an array of params based on the size of the array in the ABI and the model\r\n * @param size The amount of elements in the array\r\n * @param param The model of param to based the new array on\r\n */\r\nexport function paramFromArray(size: number, param: ABIInput) {\r\n  const type = nestedType(param.type);\r\n  const paramModel = { ...param, name: '', type: type };  // Remove name to avoid conflict\r\n  return Array(size).fill(paramModel);\r\n}\r\n\r\n/**\r\n * Return the size of the fixed array ask by the ABI\r\n * @param type The type of the array\r\n */\r\nexport function fixedArraySize(type: string): number {\r\n  const lastArrayStr = nestedArray(type).pop();\r\n  const lastArray = JSON.parse(lastArrayStr);\r\n  if (lastArray.length === 0) {\r\n    throw new Error(`Array of type ${type} is not a fixed array`);\r\n  }\r\n  return parseInt(lastArray[0], 10);\r\n}\r\n\r\n/**\r\n * Check if the tuple is static\r\n * @param tuple The tuple object\r\n */\r\nexport function isStaticTuple(tuple: ABIInput): boolean {\r\n  return (\r\n    tuple.type === 'tuple'  // Prevent type to be 'tuple[]'\r\n    && tuple.components\r\n    && tuple.components.filter(param => !isStatic(param)).length === 0\r\n  );\r\n}\r\n\r\n/**\r\n * Check if the array is static\r\n * @param arr The array object\r\n */\r\nexport function isStaticArray(arr: ABIInput): boolean {\r\n  return (\r\n    isFixedArray(arr.type)\r\n    && isStatic({...arr, type: nestedType(arr.type)}) // Nested Type is static\r\n  );\r\n}\r\n\r\n/**\r\n * Check if the output is static\r\n * @param output The output defined in the abi\r\n */\r\nexport function isStatic(output: ABIInput): boolean {\r\n  const type = output.type;\r\n  switch (true) {\r\n    // Array\r\n    case /\\[([0-9]*)\\]/.test(type):\r\n      return isStaticArray(output);\r\n    // Tuple\r\n    case /tuple?/.test(type): {\r\n      return isStaticTuple(output);\r\n    }\r\n    // Dynamic\r\n    case /string?/.test(type):\r\n    case /bytes?\\b/.test(type):\r\n      return false;\r\n    // Static\r\n    case /bytes?/.test(type):\r\n    case /int?/.test(type):\r\n    case /address?/.test(type):\r\n    case /bool?/.test(type):\r\n      return true;\r\n  }\r\n  return true;\r\n}\r\n\r\n/**\r\n * Check if the array is fixed\r\n * @param type Type of the array\r\n */\r\nexport function isFixedArray(type: string) {\r\n  return /\\[[0-9]\\]/.test(type);\r\n}\r\n\r\n/**\r\n * Remove last [] in type\r\n * @example int[32] => int\r\n * @example int[2][3] => int[2]\r\n * @param type The type to modify\r\n */\r\nexport function nestedType(type: string): string {\r\n  const arrays = nestedArray(type);\r\n  if (!arrays) { return type; }\r\n  const lastArray = arrays[arrays.length - 1];\r\n  return type.substring(0, type.length - lastArray.length);\r\n}\r\n\r\n/**\r\n * Should return array of nested types\r\n * @example int[2][3][] => [[2], [3], []]\r\n * @example int[] => [[]]\r\n * @example int => null\r\n * @param type The type to match\r\n */\r\nexport function nestedArray(type: string): string[] {\r\n  return type.match(/(\\[[0-9]*\\])/g);\r\n}\r\n\r\n","import { BN } from 'bn.js';\r\nimport { Injectable } from '@angular/core';\r\nimport { ContractModule } from './../contract.module';\r\nimport {\r\n  isStatic,\r\n  isFixedArray,\r\n  fixedArraySize,\r\n  paramFromArray,\r\n  isStaticTuple,\r\n  isStaticArray } from './utils';\r\nimport {\r\n  ABIOutput,\r\n  ABIInput,\r\n  hexToNumber,\r\n  hexToUtf8,\r\n  hexToNumberString,\r\n  toChecksumAddress\r\n} from '@ngeth/utils';\r\n\r\nexport class DecodedParam {\r\n  constructor(public result: DecodedParam, public offset: number) {}\r\n}\r\n\r\n@Injectable({ providedIn: ContractModule })\r\nexport class ABIDecoder {\r\n\r\n  /**\r\n   * Decode an event output\r\n   * @param topics The topics of the logs (indexed values)\r\n   * @param data The data of the logs (bytes)\r\n   * @param inputs The inputs givent by the ABI\r\n   */\r\n  public decodeEvent(topics: string[], data: string, inputs: ABIInput[]): any {\r\n    const outputs = this.decodeOutputs(data, inputs);\r\n    inputs\r\n      .filter(input => input.indexed)\r\n      .forEach((input, i) => {\r\n        const topic = topics[i + 1].replace('0x', '');\r\n        // If indexed value is static decode, else return as it\r\n        outputs[input.name] = isStatic(input) ? this.decodeBytes(topic, input) : topic;\r\n      });\r\n    return outputs;\r\n  }\r\n\r\n  /**\r\n   * Remap the bytes to decode depending on its type\r\n   * @param bytes The bytes to decode\r\n   * @param output The output described in the Abi\r\n   */\r\n  public decodeBytes(bytes: string, output: ABIOutput) {\r\n    const type = output.type;\r\n    // Compare true with the result of the cases\r\n    switch (true) {\r\n      // Array: Must be first\r\n      case /\\[([0-9]*)\\]/.test(type):\r\n        return this.decodeArray(bytes, output);\r\n      // Tuple\r\n      case /tuple?/.test(type):\r\n        return this.decodeTuple(bytes, output.components);\r\n      // String\r\n      case /string?/.test(type):\r\n        return this.decodeString(bytes);\r\n      // Dynamic Bytes\r\n      case /bytes?\\b/.test(type):\r\n        return this.decodeDynamicBytes(bytes);\r\n      // Bytes\r\n      case /bytes?/.test(type):\r\n        return this.decodeStaticBytes(bytes);\r\n      // Bytes\r\n      case /int?/.test(type):\r\n        return this.decodeInt(bytes);\r\n      // Address\r\n      case /address?/.test(type):\r\n        return this.decodeAddress(bytes);\r\n      // Bool\r\n      case /bool?/.test(type):\r\n        return this.decodeBool(bytes);\r\n      default: {\r\n        throw new Error('Cannot find the decoder for the type : ' + type);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Decode the outputs : Start from the last to the first (to know the length of the tail)\r\n   * @param bytes The bytes of the outputs\r\n   * @param outputs The outputs from the abi\r\n   */\r\n  public decodeOutputs(bytes: string, outputs: (ABIOutput | ABIInput)[]): any {\r\n    bytes = bytes.replace('0x', '');\r\n    const init = { result: {}, offset: bytes.length };\r\n    return outputs\r\n      .filter(output => !(<ABIInput>output).indexed) // Remove indexed values\r\n      .reduceRight((acc: DecodedParam, output: ABIOutput, i: number) => {\r\n        const head = this.getHead(bytes, outputs, i);\r\n        if (isStatic(output)) {\r\n          acc.result[output.name || i] = this.decodeBytes(head, output);\r\n          return new DecodedParam(acc.result, acc.offset);\r\n        } else {\r\n          const tailStart = hexToNumber(head) * 2; // transform bytes to hex\r\n          const tailEnd = acc.offset;\r\n          const tail = bytes.substring(tailStart, tailEnd);\r\n          acc.result[output.name || i] = this.decodeBytes(tail, output);\r\n          return new DecodedParam(acc.result, tailStart);\r\n        }\r\n      }, init\r\n    ).result;\r\n  }\r\n\r\n  /**\r\n   * Decode a array\r\n   * @param bytes The bytes of this array\r\n   * @param output The output object defined in the abi\r\n   */\r\n  public decodeArray(bytes: string, output: ABIOutput): any[] {\r\n    let amount: number;\r\n    if (isFixedArray(output.type)) {\r\n      amount = fixedArraySize(output.type);\r\n    } else {\r\n      amount = hexToNumber(bytes.slice(0, 64));\r\n    }\r\n    const nestedBytes = isFixedArray(output.type) ? bytes : bytes.slice(64);\r\n    const outputArray = paramFromArray(amount, output);\r\n    const decoded = this.decodeOutputs(nestedBytes, outputArray);\r\n    return Object.keys(decoded).map(key => decoded[key]);\r\n  }\r\n\r\n  /** Decode a tuple */\r\n  public decodeTuple(bytes: string, outputs: ABIOutput[]): any {\r\n    return this.decodeOutputs(bytes, outputs);\r\n  }\r\n\r\n  /** Decode a string */\r\n  public decodeString(bytes: string): string {\r\n    const str = bytes.slice(64);\r\n    return hexToUtf8(str);\r\n  }\r\n\r\n  /** Decode a dynamic byte */\r\n  public decodeDynamicBytes(bytes: string): string {\r\n    const amount = hexToNumber(bytes.slice(0, 64));\r\n    return bytes.slice(64).substring(0, amount * 2);\r\n  }\r\n\r\n  /** Decode a static byte */\r\n  public decodeStaticBytes(bytes: string) {\r\n    return bytes.replace(/\\b0+(0+)/, '');\r\n  }\r\n\r\n  /**\r\n   * Decode a uint or int\r\n   * WARNING : Return a string\r\n   */\r\n  public decodeInt(bytes: string): string {\r\n    const isNegative = (value: string) => {\r\n      return (new BN(value.substr(0, 1), 16).toString(2).substr(0, 1)) === '1';\r\n    }\r\n    if (isNegative(bytes)) {\r\n      return new BN(bytes, 16).fromTwos(256).toString(10);\r\n    }\r\n    return hexToNumberString(bytes);\r\n  }\r\n\r\n  /** Decode an address */\r\n  public decodeAddress(bytes: string): string {\r\n    return toChecksumAddress(bytes.substring(24));\r\n  }\r\n\r\n  /** Decode a boolean */\r\n  public decodeBool(bytes: string): boolean {\r\n    const last = bytes.substring(63);\r\n    return last === '1' ? true : false;\r\n  }\r\n\r\n  /******\r\n   * HEAD\r\n   ******/\r\n\r\n  /**\r\n   * Return the head part of the output\r\n   * @param bytes The bytes of the outputS\r\n   * @param outputs The list of outputs\r\n   * @param index The index of the output to check in the outputs\r\n   */\r\n  private getHead(bytes: string, outputs: ABIOutput[], index: number): string {\r\n    let offset = 0;\r\n    for (let i = 0; i < index; i++) {\r\n      if (isStaticTuple(outputs[i])) {\r\n        const head = this.getAllHeads(bytes.substr(offset), outputs[i].components);\r\n        offset += head.length;\r\n      } else if (isStaticArray(outputs[i])) {\r\n        offset += this.staticArraySize(bytes.substr(offset), outputs[index]);\r\n      } else {\r\n        offset += 64;\r\n      }\r\n    }\r\n    if (isStaticTuple(outputs[index])) {\r\n      const length = this.getAllHeads(bytes.substr(offset), outputs[index].components).length\r\n      return bytes.substr(offset, length);\r\n    } else if(isStaticArray(outputs[index])) {\r\n      const length = this.staticArraySize(bytes.substr(offset), outputs[index]);\r\n      return bytes.substr(offset, length);\r\n    } else {\r\n      return bytes.substr(offset, 64);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the size of a static array\r\n   * @param bytes Bytes starting at the beginning of the array\r\n   * @param output The array model\r\n   */\r\n  private staticArraySize(bytes: string, output: ABIOutput) {\r\n    const size = fixedArraySize(output.type);\r\n    const outputArray = paramFromArray(size, output);\r\n    return this.getAllHeads(bytes, outputArray).length;\r\n  }\r\n\r\n  /**\r\n   * Get all heads from static arrays or tuples\r\n   * @param bytes Bytes starting at the beginning of the array or tuple\r\n   * @param outputs The outputs given by the ABI for this array or tuple\r\n   */\r\n  private getAllHeads(bytes: string, outputs: ABIOutput[]) {\r\n    return outputs.reduceRight((acc: string, output: ABIOutput, i: number) => {\r\n        return acc + this.getHead(bytes, outputs, i);\r\n      },'');\r\n  }\r\n\r\n}\r\n","import { Injectable } from '@angular/core';\r\nimport { ABIInput, numberToHex, utf8ToHex, toBN, ABIDefinition, keccak256 } from '@ngeth/utils';\r\nimport { ContractModule } from '../contract.module';\r\nimport { isStatic, isFixedArray, paramFromArray, fixedArraySize } from './utils';\r\n\r\nexport class EncodedParam {\r\n  constructor(public head: string = '', public tail = '') {}\r\n}\r\n\r\n@Injectable({ providedIn: ContractModule })\r\nexport class ABIEncoder {\r\n  constructor() {}\r\n\r\n  /**\r\n   * Encode the constructor method for deploying\r\n   * @param constructor The constructor param defined in the ABI\r\n   * @param bytes The content of the contract\r\n   * @param args The arguments to pass into the constructor if any\r\n   */\r\n  public encodeConstructor(\r\n    constructor: ABIDefinition,\r\n    bytes: string,\r\n    args?: any[]\r\n  ) {\r\n    const encoded = this.encodeInputs(args, constructor.inputs);\r\n    return bytes + encoded.head + encoded.tail;\r\n  }\r\n\r\n  /**\r\n   * Encode the whole method\r\n   * @param mehtod The method the encode has defined in the ABI\r\n   * @param args The list of arguments given by the user\r\n   */\r\n  public encodeMethod(method: ABIDefinition, args: any[]) {\r\n    // Create and sign method\r\n    const { name, inputs } = method;\r\n    const signature = this.signMethod(method);\r\n    const hashSign = keccak256(signature).slice(0, 10);\r\n\r\n    // Create the encoded arguments\r\n    const encoded = this.encodeInputs(args, inputs);\r\n    return hashSign + encoded.head + encoded.tail;\r\n  }\r\n\r\n  /**\r\n   * Encode an event\r\n   * @param event The event to encode\r\n   */\r\n  public encodeEvent(event: ABIDefinition): string {\r\n    const { name, inputs } = event;\r\n    const signature = this.signMethod(event);\r\n    return keccak256(signature);\r\n  }\r\n\r\n  /*******************************************\r\n   *************** SIGNATURE *****************\r\n   *******************************************/\r\n\r\n  /**\r\n   * Create a string for the signature based on the params in the ABI\r\n   * @param params The params given by the ABI.\r\n   */\r\n  private signInputs(inputs: ABIInput[]): string {\r\n    return inputs\r\n      .map(input => input.components ? this.tupleType(input) : input.type)\r\n      .join(',');\r\n  }\r\n\r\n  /** Return the type of a tuple needed for the signature */\r\n  private tupleType(tuple: ABIInput): string {\r\n    const innerTypes = this.signInputs(tuple.components);\r\n    const arrayPart = tuple.type.substr(5);\r\n    return `(${innerTypes})${arrayPart}`;\r\n  }\r\n\r\n  /**\r\n   * Sign a specific method based on the ABI\r\n   * @param mehtod The method the encode has defined in the ABI\r\n   */\r\n  private signMethod(method: ABIDefinition): string {\r\n    const { name, inputs } = method;\r\n    const types = this.signInputs(inputs);\r\n    return `${name}(${types})`;\r\n  }\r\n\r\n  /*******************************************\r\n   **************** ENCODE *******************\r\n   *******************************************/\r\n\r\n  /**\r\n   * Map to the right encoder depending on the type\r\n   * @param arg the arg of the input\r\n   * @param input the input defined in the ABI\r\n   */\r\n  public encode(arg: any, input: ABIInput): string {\r\n    const type = input.type;\r\n    // Compare true with the result of the cases\r\n    switch (true) {\r\n      // Array: Must be first\r\n      case /\\[([0-9]*)\\]/.test(type): {\r\n        return this.encodeArray(arg, input);\r\n      }\r\n      // Tuple\r\n      case /tuple?/.test(type): {\r\n        // Get args given as an object\r\n        const args = Object.keys(arg).map(key => arg[key]);\r\n        return this.encodeTuple(args, input.components);\r\n      }\r\n      // String\r\n      case /string?/.test(type): {\r\n        return this.encodeString(arg);\r\n      }\r\n      // Dynamic Bytes\r\n      case /bytes?\\b/.test(type): {\r\n        return this.encodeDynamicBytes(arg);\r\n      }\r\n      // Static Bytes\r\n      case /bytes?/.test(type): {\r\n        return this.encodeStaticBytes(arg);\r\n      }\r\n      // Int / Uint\r\n      case /int?/.test(type): {\r\n        return this.encodeInt(arg, input);\r\n      }\r\n      // Address\r\n      case /address?/.test(type): {\r\n        return this.encodeAddress(arg);\r\n      }\r\n      // Bool\r\n      case /bool?/.test(type): {\r\n        return this.encodeBool(arg);\r\n      }\r\n      default: {\r\n        throw new Error('Cannot find the encoder for the type : ' + type);\r\n      }\r\n    }\r\n  }\r\n\r\n  /*******************\r\n   * STATIC OR DYNAMIC\r\n   *******************/\r\n\r\n  /**\r\n   * Encode a list of inputs\r\n   * @param args The arguments given by the users\r\n   * @param inputs The inputs defined in the ABI\r\n   */\r\n  public encodeInputs(args: any[], inputs: ABIInput[]): EncodedParam {\r\n    const offset = args.length * 64;\r\n    const init = new EncodedParam();\r\n    return inputs.reduce(\r\n      (prev: EncodedParam, input: ABIInput, i: number) => {\r\n        const encoded = this.encode(args[i], input)\r\n        const suboffset = (offset + prev.tail.length) / 2;\r\n        if (isStatic(input)) {\r\n          return new EncodedParam(prev.head + encoded, prev.tail);\r\n        } else {\r\n          let head = numberToHex(suboffset).replace('0x', '');\r\n          head = this.padStart(head, 64, '0');\r\n          return new EncodedParam(prev.head + head, prev.tail + encoded)\r\n        }\r\n      }, init\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Encode an array\r\n   * @param args The argument given by the user for this array\r\n   * @param input The input defined in the ABI\r\n   */\r\n  private encodeArray(args: any[], input: ABIInput): string {\r\n    if (args.length === 0) {\r\n      throw new Error(`No arguments found in array ${input.name}`);\r\n    }\r\n    let encoded = '';\r\n    if (!isFixedArray(input.type)) {\r\n      encoded = numberToHex(args.length).replace('0x', '')\r\n      encoded = this.padStart(encoded, 64, '0');\r\n    } else if (args.length !== fixedArraySize(input.type)) {\r\n      throw new Error(`${args} should be of size ${fixedArraySize(input.type)}`);\r\n    }\r\n    const inputs = paramFromArray(args.length, input);\r\n    const { head, tail } = this.encodeInputs(args, inputs);\r\n    return encoded + head + tail;\r\n  }\r\n\r\n  /**\r\n   * Encode the tuple\r\n   * @param args Arguments of this tuple\r\n   * @param inputs Inputs defined in the ABI\r\n   */\r\n  private encodeTuple(args: any[], inputs: ABIInput[]): string {\r\n    const { head, tail } = this.encodeInputs(args, inputs);\r\n    return head + tail;\r\n  }\r\n\r\n  /*********\r\n   * DYNAMIC\r\n   *********/\r\n\r\n  /** Encode a string */\r\n  private encodeString(arg: string): string {\r\n    if (typeof arg !== 'string') {\r\n      throw new Error(`Argument ${arg} should be a string`);\r\n    }\r\n    const hex = utf8ToHex(arg).replace('0x', '');\r\n    const size = numberToHex(arg.length).replace('0x', '')\r\n    const hexSize = hex.length + 64 - (hex.length % 64);\r\n    return this.padStart(size, 64, '0') + this.padStart(hex, hexSize, '0');\r\n  }\r\n\r\n  /**\r\n   * Encode a dynamic bytes\r\n   * @example bytes\r\n   */\r\n  private encodeDynamicBytes(arg: string) {\r\n    if (typeof arg !== 'string') {\r\n      throw new Error(`Argument ${arg} should be a string`);\r\n    }\r\n    const hex = arg.replace('0x', '');\r\n    const size = numberToHex(hex.length / 2).replace('0x', '');\r\n    const hexSize = hex.length + 64 - (hex.length % 64);\r\n    return this.padStart(size, 64, '0') + this.padEnd(hex, hexSize, '0');\r\n  }\r\n\r\n  /********\r\n   * STATIC\r\n   ********/\r\n\r\n  /**\r\n   * Encode a static bytes\r\n   * @example bytes3, bytes32\r\n   */\r\n  private encodeStaticBytes(arg: string | number) {\r\n    if (typeof arg !== 'string' && typeof arg !== 'number') {\r\n      throw new Error(`Argument ${arg} should be a string or number`);\r\n    }\r\n    if (typeof arg === 'number') { arg = arg.toString(16); }\r\n    const result = arg.replace('0x', '');\r\n    return this.padEnd(result, 46, '0');\r\n  }\r\n\r\n  /**\r\n   * Encode int or uint\r\n   * @example int, int32, uint256\r\n   */\r\n  private encodeInt(arg: number, input: ABIInput) {\r\n    if (typeof arg !== 'number') {\r\n      throw new Error(`Argument ${arg} should be a number`);\r\n    }\r\n    if (arg % 1 !== 0) {\r\n      throw new Error('Only provider integers, Solidity does not manage floats');\r\n    }\r\n    if (input.type.includes('uint') && arg < 0) {\r\n      throw new Error(`\"uint\" cannot be negative at value ${arg}`)\r\n    }\r\n    return toBN(arg).toTwos(256).toString(16, 64);\r\n  }\r\n\r\n  /** Encode an address */\r\n  private encodeAddress(arg: string | number) {\r\n    if (typeof arg !== 'string' && typeof arg !== 'number') {\r\n      throw new Error(`Argument ${arg} should be a string or number`);\r\n    }\r\n    if (typeof arg === 'number') { arg = arg.toString(16); }\r\n    const result = arg.replace('0x', '');\r\n    return this.padStart(result, 64, '0');\r\n  }\r\n\r\n  /** Encode a boolean */\r\n  private encodeBool(arg: boolean): string {\r\n    if (typeof arg !== 'boolean') {\r\n      throw new Error(`Argument ${arg} should be a boolean`);\r\n    }\r\n    return arg ? this.padStart('1', 64, '0') : this.padStart('0', 64, '0');\r\n  }\r\n\r\n  /***\r\n   * PadStart / PadEnd\r\n   */\r\n  private padStart(target: string, targetLength: number, padString: string): string {\r\n    /* tslint:disable */\r\n    targetLength = targetLength >> 0; //truncate if number or convert non-number to 0;\r\n    /* tslint:enable */\r\n    padString = String(typeof padString !== 'undefined' ? padString : ' ');\r\n    if (target.length > targetLength) {\r\n      return String(target);\r\n    } else {\r\n      targetLength = targetLength - target.length;\r\n      if (targetLength > padString.length) {\r\n        padString += padString.repeat(targetLength / padString.length); //append to original to ensure we are longer than needed\r\n      }\r\n      return padString.slice(0, targetLength) + String(target);\r\n    }\r\n  };\r\n\r\n  private padEnd(target: string, targetLength: number, padString: string): string{\r\n    /* tslint:disable */\r\n    targetLength = targetLength >> 0; //floor if number or convert non-number to 0;\r\n    /* tslint:enable */\r\n    padString = String(typeof padString !== 'undefined' ? padString : ' ');\r\n    if (target.length > targetLength) {\r\n      return String(target);\r\n    } else {\r\n      targetLength = targetLength - target.length;\r\n      if (targetLength > padString.length) {\r\n        padString += padString.repeat(targetLength / padString.length); //append to original to ensure we are longer than needed\r\n      }\r\n      return String(target) + padString.slice(0, targetLength);\r\n    }\r\n  };\r\n}\r\n","import { ContractModel } from '@ngeth/utils';\r\nimport { Injectable, Type } from '@angular/core';\r\nimport { ContractProvider } from '@ngeth/provider';\r\nimport { ABIEncoder, ABIDecoder } from './abi';\r\nimport { ContractModule } from './contract.module';\r\nimport { ContractClass } from './contract';\r\n\r\nexport function Contract<T extends ContractModel>(metadata: {\r\n  provider?: Type<ContractProvider>;  // TODO : Use for custom provider (with Auth)\r\n  abi: any[] | string;\r\n  addresses?: {\r\n    mainnet?: string;\r\n    ropsten?: string;\r\n    rinkeby?: string;\r\n    kovan?: string;\r\n  };\r\n}) {\r\n  const { abi, addresses } = metadata;\r\n  const jsonInterace: any[] = typeof abi === 'string' ? JSON.parse(abi) : abi;\r\n\r\n  /**\r\n   * Get the address of the contract depending on the id of the network\r\n   * @param id The id of the network\r\n   */\r\n  const getAddress = (id: number): string => {\r\n    switch(id) {\r\n      case 1: return addresses['mainnet'];\r\n      case 3: return addresses['ropsten'];\r\n      case 4: return addresses['rinkeby'];\r\n      case 42: return addresses['kovan'];\r\n      default: return addresses['mainnet'];\r\n    }\r\n  }\r\n\r\n  return function(Base) {\r\n    @Injectable({ providedIn: ContractModule })\r\n    class ContractDecorated extends ContractClass<T> {\r\n      constructor(\r\n        protected encoder: ABIEncoder,\r\n        protected decoder: ABIDecoder,\r\n        protected provider: ContractProvider\r\n      ) {\r\n        super(encoder, decoder, provider, jsonInterace, getAddress(provider.id));\r\n      }\r\n    }\r\n    return ContractDecorated as any;\r\n  };\r\n}\r\n","import { ContractClass } from '../../contract';\r\nimport { Contract } from '../../contract.decorator';\r\nimport { IEncoderTestContract } from './encoder-test.models';\r\nconst abi = require('./encoder-test.abi.json');\r\n\r\n@Contract<IEncoderTestContract>({\r\n  abi: abi,\r\n  addresses: {\r\n    ropsten: '0x344f641ff60f6308ad70b1e62052764835f48e00'\r\n  }\r\n})\r\nexport class EncoderTestContract extends ContractClass<IEncoderTestContract> {}\r\n","import { ContractClass } from '../../contract';\r\nimport { Contract,  } from '../../contract.decorator';\r\nimport { ITestEventContract } from './test-event.models';\r\nconst abi = require('./test-event.abi.json');\r\n\r\n@Contract<ITestEventContract>({\r\n  abi: abi,\r\n  addresses: {\r\n    ropsten: '0xc0D6C4cbA14aeFC218d0ff669e07D73E74078248'\r\n  }\r\n})\r\nexport class TestEventContract extends ContractClass<ITestEventContract> {}\r\n"],"names":["provider","toChecksumAddress","tslib_1.__values","switchMap","map","forkJoin","NgModule","hexToNumber","hexToUtf8","BN","hexToNumberString","Injectable","keccak256","numberToHex","utf8ToHex","toBN","tslib_1.__extends","ContractProvider","abi"],"mappings":"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"}
