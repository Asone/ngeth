{"version":3,"sources":["null","ng://@ngeth/contract/lib/contract.ts","ng://@ngeth/contract/lib/contract.module.ts","ng://@ngeth/contract/lib/abi/utils.ts","ng://@ngeth/contract/lib/abi/decoder.ts","ng://@ngeth/contract/lib/abi/encoder.ts","ng://@ngeth/contract/lib/contract.decorator.ts","ng://@ngeth/contract/lib/abi/encoder-test/encoder-test.contract.ts","ng://@ngeth/contract/lib/abi/test-event/test-event.contract.ts"],"names":["extendStatics","Object","setPrototypeOf","__proto__","Array","d","b","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","__assign","assign","t","s","i","n","arguments","length","call","__decorate","decorators","target","key","desc","c","r","getOwnPropertyDescriptor","Reflect","decorate","defineProperty","ContractClass","encoder","decoder","provider","abi","address","_this","Error","toChecksumAddress","calls","sends","events","_a","o","m","Symbol","iterator","next","value","done","tslib_1.__values","_b","def","type","constant","push","forEach","name","callMethod","bind","sendMethod","eventMethod","deploy","bytes","params","_i","find","data","encodeConstructor","fillGas","defaultTx","pipe","switchMap","tx","sendTransaction","method","encodeMethod","map","result","decodeOutputs","outputs","keys","to","event","topics","encodeEvent","logs","decodeEvent","inputs","forkJoin","estimateGas","gasPrice","e","ar","error","__read","gas","ContractModule","NgModule","paramFromArray","size","param","nestedType","paramModel","fill","fixedArraySize","lastArrayStr","nestedArray","pop","lastArray","JSON","parse","parseInt","isStaticTuple","tuple","components","filter","isStatic","isStaticArray","arr","isFixedArray","output","test","arrays","substring","match","DecodedParam","offset","ABIDecoder","input","indexed","topic","replace","decodeBytes","decodeArray","decodeTuple","decodeString","decodeDynamicBytes","decodeStaticBytes","decodeInt","decodeAddress","decodeBool","init","reduceRight","acc","head","getHead","tailStart","hexToNumber","tailEnd","tail","amount","slice","nestedBytes","outputArray","decoded","str","hexToUtf8","BN","substr","toString","fromTwos","hexToNumberString","index","getAllHeads","staticArraySize","length_1","length_2","Injectable","args","providedIn","EncodedParam","ABIEncoder","encoded","encodeInputs","signature","signMethod","hashSign","keccak256","signInputs","tupleType","join","encode","arg","encodeArray","encodeTuple","encodeString","encodeDynamicBytes","encodeStaticBytes","encodeInt","encodeAddress","encodeBool","reduce","prev","suboffset","numberToHex","padStart","hex","utf8ToHex","hexSize","padEnd","includes","toBN","toTwos","targetLength","padString","String","repeat","Contract","metadata","addresses","jsonInterace","Base","ContractDecorated","_super","id","getAddress","tslib_1.__extends","ContractProvider","require","EncoderTestContract","ropsten","TestEventContract"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = Object.assign || function __assign(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n    }\r\n    return t;\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; }; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator];\r\n    return m ? m.call(o) : typeof __values === \"function\" ? __values(o) : o[Symbol.iterator]();\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { ABIDefinition, toChecksumAddress, ContractModel, ITxObject } from '@ngeth/utils';\r\nimport { ContractProvider } from '@ngeth/provider';\r\nimport { ABIEncoder, ABIDecoder } from './abi';\r\n\r\nimport { Observable, forkJoin } from 'rxjs';\r\nimport { map,  switchMap } from 'rxjs/operators';\r\n\r\nexport class ContractClass<T extends ContractModel> {\r\n  public calls: { [P in keyof T['calls']]: T['calls'][P]; } = {} as any;\r\n  public sends: { [P in keyof T['sends']]: T['sends'][P]; } = {} as any;\r\n  public events: { [P in keyof T['events']]: T['events'][P]; } = {} as any;\r\n\r\n  constructor(\r\n    protected encoder: ABIEncoder,\r\n    protected decoder: ABIDecoder,\r\n    protected provider: ContractProvider,\r\n    private abi: ABIDefinition[],\r\n    public address?: string\r\n  ) {\r\n    if (!this.abi) { throw new Error('Please add an abi to the contract'); }\r\n    if (this.address) { this.address = toChecksumAddress(address); }\r\n    const calls: any[] = [];\r\n    const sends: any[] = [];\r\n    const events: any[] = [];\r\n    for (const def of this.abi) {\r\n      if (def.type === 'function' && def.constant === true) {\r\n        calls.push(def);\r\n      }\r\n      if (def.type === 'function' && def.constant === false) {\r\n        sends.push(def);\r\n      }\r\n      if (def.type === 'event') {\r\n        events.push(def);\r\n      }\r\n    }\r\n    calls.forEach(def => (this.calls[def.name] = this.callMethod.bind(this, def)));\r\n    sends.forEach(def => (this.sends[def.name] = this.sendMethod.bind(this, def)));\r\n    events.forEach(def => (this.events[def.name] = this.eventMethod.bind(this, def)));\r\n  }\r\n\r\n  /**\r\n   * Deploy the contract on the blockchain\r\n   * @param bytes The bytes of the contract\r\n   * @param params Params to pass into the constructor\r\n   */\r\n  public deploy(bytes: string, ...params: any[]) {\r\n    const constructor = this.abi.find(def => def.type === 'constructor');\r\n    const noParam = params.length === 0;\r\n    const data = noParam ? bytes : this.encoder.encodeConstructor(constructor, bytes, params);\r\n    return this.fillGas({ ...this.provider.defaultTx, data })\r\n      .pipe(switchMap(tx => this.provider.sendTransaction(tx)));\r\n  }\r\n\r\n  /**\r\n   * Used for 'call' methods\r\n   * @param method The method to call\r\n   * @param params The params given by the user\r\n   */\r\n  private callMethod(method: ABIDefinition, ...params: any[]) {\r\n    const data = this.encoder.encodeMethod(method, params);\r\n    return this.provider\r\n      .call<string>(this.address, data)\r\n      .pipe(\r\n        map(result => this.decoder.decodeOutputs(result, method.outputs)),\r\n        map(result => result[Object.keys(result)[0]])\r\n      );\r\n  }\r\n\r\n  /**\r\n   * Used for 'send' methods\r\n   * @param method The method to send\r\n   * @param params The params given by the user\r\n   */\r\n  private sendMethod(method: ABIDefinition, ...params: any[]) {\r\n    const { to, data } = { to: this.address, data: this.encoder.encodeMethod(method, params) };\r\n    return this.fillGas({ ...this.provider.defaultTx, to, data })\r\n      .pipe(switchMap(tx => this.provider.sendTransaction(tx)));\r\n  }\r\n\r\n  /**\r\n   * Used for 'event' definition\r\n   * @param event The event definition in the ABI\r\n   */\r\n  private eventMethod(event: ABIDefinition) {\r\n    const topics = this.encoder.encodeEvent(event);\r\n    return this.provider.event(this.address, [topics]).pipe(\r\n      map(logs => this.decoder.decodeEvent(logs.topics, logs.data, event.inputs))\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Fill the estimated amount of gas and gasPrice to use for a transaction\r\n   * @param tx The raw transaction to estimate the gas from\r\n   */\r\n  private fillGas(tx: Partial<ITxObject>): Observable<Partial<ITxObject>> {\r\n    return forkJoin(\r\n      this.provider.estimateGas(tx),\r\n      this.provider.gasPrice()\r\n    ).pipe(map(([gas, gasPrice]) => {\r\n        return { ...tx, gas, gasPrice }\r\n      })\r\n    );\r\n  }\r\n\r\n}\r\n","import { NgModule } from '@angular/core';\r\n\r\n@NgModule()\r\nexport class ContractModule {}\r\n","import { ABIInput } from '@ngeth/utils';\r\n\r\n/**\r\n * Create an array of params based on the size of the array in the ABI and the model\r\n * @param size The amount of elements in the array\r\n * @param param The model of param to based the new array on\r\n */\r\nexport function paramFromArray(size: number, param: ABIInput) {\r\n  const type = nestedType(param.type);\r\n  const paramModel = { ...param, name: '', type: type };  // Remove name to avoid conflict\r\n  return Array(size).fill(paramModel);\r\n}\r\n\r\n/**\r\n * Return the size of the fixed array ask by the ABI\r\n * @param type The type of the array\r\n */\r\nexport function fixedArraySize(type: string): number {\r\n  const lastArrayStr = nestedArray(type).pop();\r\n  const lastArray = JSON.parse(lastArrayStr);\r\n  if (lastArray.length === 0) {\r\n    throw new Error(`Array of type ${type} is not a fixed array`);\r\n  }\r\n  return parseInt(lastArray[0], 10);\r\n}\r\n\r\n/**\r\n * Check if the tuple is static\r\n * @param tuple The tuple object\r\n */\r\nexport function isStaticTuple(tuple: ABIInput): boolean {\r\n  return (\r\n    tuple.type === 'tuple'  // Prevent type to be 'tuple[]'\r\n    && tuple.components\r\n    && tuple.components.filter(param => !isStatic(param)).length === 0\r\n  );\r\n}\r\n\r\n/**\r\n * Check if the array is static\r\n * @param arr The array object\r\n */\r\nexport function isStaticArray(arr: ABIInput): boolean {\r\n  return (\r\n    isFixedArray(arr.type)\r\n    && isStatic({...arr, type: nestedType(arr.type)}) // Nested Type is static\r\n  );\r\n}\r\n\r\n/**\r\n * Check if the output is static\r\n * @param output The output defined in the abi\r\n */\r\nexport function isStatic(output: ABIInput): boolean {\r\n  const type = output.type;\r\n  switch (true) {\r\n    // Array\r\n    case /\\[([0-9]*)\\]/.test(type):\r\n      return isStaticArray(output);\r\n    // Tuple\r\n    case /tuple?/.test(type): {\r\n      return isStaticTuple(output);\r\n    }\r\n    // Dynamic\r\n    case /string?/.test(type):\r\n    case /bytes?\\b/.test(type):\r\n      return false;\r\n    // Static\r\n    case /bytes?/.test(type):\r\n    case /int?/.test(type):\r\n    case /address?/.test(type):\r\n    case /bool?/.test(type):\r\n      return true;\r\n  }\r\n  return true;\r\n}\r\n\r\n/**\r\n * Check if the array is fixed\r\n * @param type Type of the array\r\n */\r\nexport function isFixedArray(type: string) {\r\n  return /\\[[0-9]\\]/.test(type);\r\n}\r\n\r\n/**\r\n * Remove last [] in type\r\n * @example int[32] => int\r\n * @example int[2][3] => int[2]\r\n * @param type The type to modify\r\n */\r\nexport function nestedType(type: string): string {\r\n  const arrays = nestedArray(type);\r\n  if (!arrays) { return type; }\r\n  const lastArray = arrays[arrays.length - 1];\r\n  return type.substring(0, type.length - lastArray.length);\r\n}\r\n\r\n/**\r\n * Should return array of nested types\r\n * @example int[2][3][] => [[2], [3], []]\r\n * @example int[] => [[]]\r\n * @example int => null\r\n * @param type The type to match\r\n */\r\nexport function nestedArray(type: string): string[] {\r\n  return type.match(/(\\[[0-9]*\\])/g);\r\n}\r\n\r\n","import { BN } from 'bn.js';\r\nimport { Injectable } from '@angular/core';\r\nimport { ContractModule } from './../contract.module';\r\nimport {\r\n  isStatic,\r\n  isFixedArray,\r\n  fixedArraySize,\r\n  paramFromArray,\r\n  isStaticTuple,\r\n  isStaticArray } from './utils';\r\nimport {\r\n  ABIOutput,\r\n  ABIInput,\r\n  hexToNumber,\r\n  hexToUtf8,\r\n  hexToNumberString,\r\n  toChecksumAddress\r\n} from '@ngeth/utils';\r\n\r\nexport class DecodedParam {\r\n  constructor(public result: DecodedParam, public offset: number) {}\r\n}\r\n\r\n@Injectable({ providedIn: ContractModule })\r\nexport class ABIDecoder {\r\n\r\n  /**\r\n   * Decode an event output\r\n   * @param topics The topics of the logs (indexed values)\r\n   * @param data The data of the logs (bytes)\r\n   * @param inputs The inputs givent by the ABI\r\n   */\r\n  public decodeEvent(topics: string[], data: string, inputs: ABIInput[]): any {\r\n    const outputs = this.decodeOutputs(data, inputs);\r\n    inputs\r\n      .filter(input => input.indexed)\r\n      .forEach((input, i) => {\r\n        const topic = topics[i + 1].replace('0x', '');\r\n        // If indexed value is static decode, else return as it\r\n        outputs[input.name] = isStatic(input) ? this.decodeBytes(topic, input) : topic;\r\n      });\r\n    return outputs;\r\n  }\r\n\r\n  /**\r\n   * Remap the bytes to decode depending on its type\r\n   * @param bytes The bytes to decode\r\n   * @param output The output described in the Abi\r\n   */\r\n  public decodeBytes(bytes: string, output: ABIOutput) {\r\n    const type = output.type;\r\n    // Compare true with the result of the cases\r\n    switch (true) {\r\n      // Array: Must be first\r\n      case /\\[([0-9]*)\\]/.test(type):\r\n        return this.decodeArray(bytes, output);\r\n      // Tuple\r\n      case /tuple?/.test(type):\r\n        return this.decodeTuple(bytes, output.components);\r\n      // String\r\n      case /string?/.test(type):\r\n        return this.decodeString(bytes);\r\n      // Dynamic Bytes\r\n      case /bytes?\\b/.test(type):\r\n        return this.decodeDynamicBytes(bytes);\r\n      // Bytes\r\n      case /bytes?/.test(type):\r\n        return this.decodeStaticBytes(bytes);\r\n      // Bytes\r\n      case /int?/.test(type):\r\n        return this.decodeInt(bytes);\r\n      // Address\r\n      case /address?/.test(type):\r\n        return this.decodeAddress(bytes);\r\n      // Bool\r\n      case /bool?/.test(type):\r\n        return this.decodeBool(bytes);\r\n      default: {\r\n        throw new Error('Cannot find the decoder for the type : ' + type);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Decode the outputs : Start from the last to the first (to know the length of the tail)\r\n   * @param bytes The bytes of the outputs\r\n   * @param outputs The outputs from the abi\r\n   */\r\n  public decodeOutputs(bytes: string, outputs: (ABIOutput | ABIInput)[]): any {\r\n    bytes = bytes.replace('0x', '');\r\n    const init = { result: {}, offset: bytes.length };\r\n    return outputs\r\n      .filter(output => !(<ABIInput>output).indexed) // Remove indexed values\r\n      .reduceRight((acc: DecodedParam, output: ABIOutput, i: number) => {\r\n        const head = this.getHead(bytes, outputs, i);\r\n        if (isStatic(output)) {\r\n          acc.result[output.name || i] = this.decodeBytes(head, output);\r\n          return new DecodedParam(acc.result, acc.offset);\r\n        } else {\r\n          const tailStart = hexToNumber(head) * 2; // transform bytes to hex\r\n          const tailEnd = acc.offset;\r\n          const tail = bytes.substring(tailStart, tailEnd);\r\n          acc.result[output.name || i] = this.decodeBytes(tail, output);\r\n          return new DecodedParam(acc.result, tailStart);\r\n        }\r\n      }, init\r\n    ).result;\r\n  }\r\n\r\n  /**\r\n   * Decode a array\r\n   * @param bytes The bytes of this array\r\n   * @param output The output object defined in the abi\r\n   */\r\n  public decodeArray(bytes: string, output: ABIOutput): any[] {\r\n    let amount: number;\r\n    if (isFixedArray(output.type)) {\r\n      amount = fixedArraySize(output.type);\r\n    } else {\r\n      amount = hexToNumber(bytes.slice(0, 64));\r\n    }\r\n    const nestedBytes = isFixedArray(output.type) ? bytes : bytes.slice(64);\r\n    const outputArray = paramFromArray(amount, output);\r\n    const decoded = this.decodeOutputs(nestedBytes, outputArray);\r\n    return Object.keys(decoded).map(key => decoded[key]);\r\n  }\r\n\r\n  /** Decode a tuple */\r\n  public decodeTuple(bytes: string, outputs: ABIOutput[]): any {\r\n    return this.decodeOutputs(bytes, outputs);\r\n  }\r\n\r\n  /** Decode a string */\r\n  public decodeString(bytes: string): string {\r\n    const str = bytes.slice(64);\r\n    return hexToUtf8(str);\r\n  }\r\n\r\n  /** Decode a dynamic byte */\r\n  public decodeDynamicBytes(bytes: string): string {\r\n    const amount = hexToNumber(bytes.slice(0, 64));\r\n    return bytes.slice(64).substring(0, amount * 2);\r\n  }\r\n\r\n  /** Decode a static byte */\r\n  public decodeStaticBytes(bytes: string) {\r\n    return bytes.replace(/\\b0+(0+)/, '');\r\n  }\r\n\r\n  /**\r\n   * Decode a uint or int\r\n   * WARNING : Return a string\r\n   */\r\n  public decodeInt(bytes: string): string {\r\n    const isNegative = (value: string) => {\r\n      return (new BN(value.substr(0, 1), 16).toString(2).substr(0, 1)) === '1';\r\n    }\r\n    if (isNegative(bytes)) {\r\n      return new BN(bytes, 16).fromTwos(256).toString(10);\r\n    }\r\n    return hexToNumberString(bytes);\r\n  }\r\n\r\n  /** Decode an address */\r\n  public decodeAddress(bytes: string): string {\r\n    return toChecksumAddress(bytes.substring(24));\r\n  }\r\n\r\n  /** Decode a boolean */\r\n  public decodeBool(bytes: string): boolean {\r\n    const last = bytes.substring(63);\r\n    return last === '1' ? true : false;\r\n  }\r\n\r\n  /******\r\n   * HEAD\r\n   ******/\r\n\r\n  /**\r\n   * Return the head part of the output\r\n   * @param bytes The bytes of the outputS\r\n   * @param outputs The list of outputs\r\n   * @param index The index of the output to check in the outputs\r\n   */\r\n  private getHead(bytes: string, outputs: ABIOutput[], index: number): string {\r\n    let offset = 0;\r\n    for (let i = 0; i < index; i++) {\r\n      if (isStaticTuple(outputs[i])) {\r\n        const head = this.getAllHeads(bytes.substr(offset), outputs[i].components);\r\n        offset += head.length;\r\n      } else if (isStaticArray(outputs[i])) {\r\n        offset += this.staticArraySize(bytes.substr(offset), outputs[index]);\r\n      } else {\r\n        offset += 64;\r\n      }\r\n    }\r\n    if (isStaticTuple(outputs[index])) {\r\n      const length = this.getAllHeads(bytes.substr(offset), outputs[index].components).length\r\n      return bytes.substr(offset, length);\r\n    } else if(isStaticArray(outputs[index])) {\r\n      const length = this.staticArraySize(bytes.substr(offset), outputs[index]);\r\n      return bytes.substr(offset, length);\r\n    } else {\r\n      return bytes.substr(offset, 64);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the size of a static array\r\n   * @param bytes Bytes starting at the beginning of the array\r\n   * @param output The array model\r\n   */\r\n  private staticArraySize(bytes: string, output: ABIOutput) {\r\n    const size = fixedArraySize(output.type);\r\n    const outputArray = paramFromArray(size, output);\r\n    return this.getAllHeads(bytes, outputArray).length;\r\n  }\r\n\r\n  /**\r\n   * Get all heads from static arrays or tuples\r\n   * @param bytes Bytes starting at the beginning of the array or tuple\r\n   * @param outputs The outputs given by the ABI for this array or tuple\r\n   */\r\n  private getAllHeads(bytes: string, outputs: ABIOutput[]) {\r\n    return outputs.reduceRight((acc: string, output: ABIOutput, i: number) => {\r\n        return acc + this.getHead(bytes, outputs, i);\r\n      },'');\r\n  }\r\n\r\n}\r\n","import { Injectable } from '@angular/core';\r\nimport { ABIInput, numberToHex, utf8ToHex, toBN, ABIDefinition, keccak256 } from '@ngeth/utils';\r\nimport { ContractModule } from '../contract.module';\r\nimport { isStatic, isFixedArray, paramFromArray, fixedArraySize } from './utils';\r\n\r\nexport class EncodedParam {\r\n  constructor(public head: string = '', public tail = '') {}\r\n}\r\n\r\n@Injectable({ providedIn: ContractModule })\r\nexport class ABIEncoder {\r\n  constructor() {}\r\n\r\n  /**\r\n   * Encode the constructor method for deploying\r\n   * @param constructor The constructor param defined in the ABI\r\n   * @param bytes The content of the contract\r\n   * @param args The arguments to pass into the constructor if any\r\n   */\r\n  public encodeConstructor(\r\n    constructor: ABIDefinition,\r\n    bytes: string,\r\n    args?: any[]\r\n  ) {\r\n    const encoded = this.encodeInputs(args, constructor.inputs);\r\n    return bytes + encoded.head + encoded.tail;\r\n  }\r\n\r\n  /**\r\n   * Encode the whole method\r\n   * @param mehtod The method the encode has defined in the ABI\r\n   * @param args The list of arguments given by the user\r\n   */\r\n  public encodeMethod(method: ABIDefinition, args: any[]) {\r\n    // Create and sign method\r\n    const { name, inputs } = method;\r\n    const signature = this.signMethod(method);\r\n    const hashSign = keccak256(signature).slice(0, 10);\r\n\r\n    // Create the encoded arguments\r\n    const encoded = this.encodeInputs(args, inputs);\r\n    return hashSign + encoded.head + encoded.tail;\r\n  }\r\n\r\n  /**\r\n   * Encode an event\r\n   * @param event The event to encode\r\n   */\r\n  public encodeEvent(event: ABIDefinition): string {\r\n    const { name, inputs } = event;\r\n    const signature = this.signMethod(event);\r\n    return keccak256(signature);\r\n  }\r\n\r\n  /*******************************************\r\n   *************** SIGNATURE *****************\r\n   *******************************************/\r\n\r\n  /**\r\n   * Create a string for the signature based on the params in the ABI\r\n   * @param params The params given by the ABI.\r\n   */\r\n  private signInputs(inputs: ABIInput[]): string {\r\n    return inputs\r\n      .map(input => input.components ? this.tupleType(input) : input.type)\r\n      .join(',');\r\n  }\r\n\r\n  /** Return the type of a tuple needed for the signature */\r\n  private tupleType(tuple: ABIInput): string {\r\n    const innerTypes = this.signInputs(tuple.components);\r\n    const arrayPart = tuple.type.substr(5);\r\n    return `(${innerTypes})${arrayPart}`;\r\n  }\r\n\r\n  /**\r\n   * Sign a specific method based on the ABI\r\n   * @param mehtod The method the encode has defined in the ABI\r\n   */\r\n  private signMethod(method: ABIDefinition): string {\r\n    const { name, inputs } = method;\r\n    const types = this.signInputs(inputs);\r\n    return `${name}(${types})`;\r\n  }\r\n\r\n  /*******************************************\r\n   **************** ENCODE *******************\r\n   *******************************************/\r\n\r\n  /**\r\n   * Map to the right encoder depending on the type\r\n   * @param arg the arg of the input\r\n   * @param input the input defined in the ABI\r\n   */\r\n  public encode(arg: any, input: ABIInput): string {\r\n    const type = input.type;\r\n    // Compare true with the result of the cases\r\n    switch (true) {\r\n      // Array: Must be first\r\n      case /\\[([0-9]*)\\]/.test(type): {\r\n        return this.encodeArray(arg, input);\r\n      }\r\n      // Tuple\r\n      case /tuple?/.test(type): {\r\n        // Get args given as an object\r\n        const args = Object.keys(arg).map(key => arg[key]);\r\n        return this.encodeTuple(args, input.components);\r\n      }\r\n      // String\r\n      case /string?/.test(type): {\r\n        return this.encodeString(arg);\r\n      }\r\n      // Dynamic Bytes\r\n      case /bytes?\\b/.test(type): {\r\n        return this.encodeDynamicBytes(arg);\r\n      }\r\n      // Static Bytes\r\n      case /bytes?/.test(type): {\r\n        return this.encodeStaticBytes(arg);\r\n      }\r\n      // Int / Uint\r\n      case /int?/.test(type): {\r\n        return this.encodeInt(arg, input);\r\n      }\r\n      // Address\r\n      case /address?/.test(type): {\r\n        return this.encodeAddress(arg);\r\n      }\r\n      // Bool\r\n      case /bool?/.test(type): {\r\n        return this.encodeBool(arg);\r\n      }\r\n      default: {\r\n        throw new Error('Cannot find the encoder for the type : ' + type);\r\n      }\r\n    }\r\n  }\r\n\r\n  /*******************\r\n   * STATIC OR DYNAMIC\r\n   *******************/\r\n\r\n  /**\r\n   * Encode a list of inputs\r\n   * @param args The arguments given by the users\r\n   * @param inputs The inputs defined in the ABI\r\n   */\r\n  public encodeInputs(args: any[], inputs: ABIInput[]): EncodedParam {\r\n    const offset = args.length * 64;\r\n    const init = new EncodedParam();\r\n    return inputs.reduce(\r\n      (prev: EncodedParam, input: ABIInput, i: number) => {\r\n        const encoded = this.encode(args[i], input)\r\n        const suboffset = (offset + prev.tail.length) / 2;\r\n        if (isStatic(input)) {\r\n          return new EncodedParam(prev.head + encoded, prev.tail);\r\n        } else {\r\n          let head = numberToHex(suboffset).replace('0x', '');\r\n          head = this.padStart(head, 64, '0');\r\n          return new EncodedParam(prev.head + head, prev.tail + encoded)\r\n        }\r\n      }, init\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Encode an array\r\n   * @param args The argument given by the user for this array\r\n   * @param input The input defined in the ABI\r\n   */\r\n  private encodeArray(args: any[], input: ABIInput): string {\r\n    if (args.length === 0) {\r\n      throw new Error(`No arguments found in array ${input.name}`);\r\n    }\r\n    let encoded = '';\r\n    if (!isFixedArray(input.type)) {\r\n      encoded = numberToHex(args.length).replace('0x', '')\r\n      encoded = this.padStart(encoded, 64, '0');\r\n    } else if (args.length !== fixedArraySize(input.type)) {\r\n      throw new Error(`${args} should be of size ${fixedArraySize(input.type)}`);\r\n    }\r\n    const inputs = paramFromArray(args.length, input);\r\n    const { head, tail } = this.encodeInputs(args, inputs);\r\n    return encoded + head + tail;\r\n  }\r\n\r\n  /**\r\n   * Encode the tuple\r\n   * @param args Arguments of this tuple\r\n   * @param inputs Inputs defined in the ABI\r\n   */\r\n  private encodeTuple(args: any[], inputs: ABIInput[]): string {\r\n    const { head, tail } = this.encodeInputs(args, inputs);\r\n    return head + tail;\r\n  }\r\n\r\n  /*********\r\n   * DYNAMIC\r\n   *********/\r\n\r\n  /** Encode a string */\r\n  private encodeString(arg: string): string {\r\n    if (typeof arg !== 'string') {\r\n      throw new Error(`Argument ${arg} should be a string`);\r\n    }\r\n    const hex = utf8ToHex(arg).replace('0x', '');\r\n    const size = numberToHex(arg.length).replace('0x', '')\r\n    const hexSize = hex.length + 64 - (hex.length % 64);\r\n    return this.padStart(size, 64, '0') + this.padStart(hex, hexSize, '0');\r\n  }\r\n\r\n  /**\r\n   * Encode a dynamic bytes\r\n   * @example bytes\r\n   */\r\n  private encodeDynamicBytes(arg: string) {\r\n    if (typeof arg !== 'string') {\r\n      throw new Error(`Argument ${arg} should be a string`);\r\n    }\r\n    const hex = arg.replace('0x', '');\r\n    const size = numberToHex(hex.length / 2).replace('0x', '');\r\n    const hexSize = hex.length + 64 - (hex.length % 64);\r\n    return this.padStart(size, 64, '0') + this.padEnd(hex, hexSize, '0');\r\n  }\r\n\r\n  /********\r\n   * STATIC\r\n   ********/\r\n\r\n  /**\r\n   * Encode a static bytes\r\n   * @example bytes3, bytes32\r\n   */\r\n  private encodeStaticBytes(arg: string | number) {\r\n    if (typeof arg !== 'string' && typeof arg !== 'number') {\r\n      throw new Error(`Argument ${arg} should be a string or number`);\r\n    }\r\n    if (typeof arg === 'number') { arg = arg.toString(16); }\r\n    const result = arg.replace('0x', '');\r\n    return this.padEnd(result, 46, '0');\r\n  }\r\n\r\n  /**\r\n   * Encode int or uint\r\n   * @example int, int32, uint256\r\n   */\r\n  private encodeInt(arg: number, input: ABIInput) {\r\n    if (typeof arg !== 'number') {\r\n      throw new Error(`Argument ${arg} should be a number`);\r\n    }\r\n    if (arg % 1 !== 0) {\r\n      throw new Error('Only provider integers, Solidity does not manage floats');\r\n    }\r\n    if (input.type.includes('uint') && arg < 0) {\r\n      throw new Error(`\"uint\" cannot be negative at value ${arg}`)\r\n    }\r\n    return toBN(arg).toTwos(256).toString(16, 64);\r\n  }\r\n\r\n  /** Encode an address */\r\n  private encodeAddress(arg: string | number) {\r\n    if (typeof arg !== 'string' && typeof arg !== 'number') {\r\n      throw new Error(`Argument ${arg} should be a string or number`);\r\n    }\r\n    if (typeof arg === 'number') { arg = arg.toString(16); }\r\n    const result = arg.replace('0x', '');\r\n    return this.padStart(result, 64, '0');\r\n  }\r\n\r\n  /** Encode a boolean */\r\n  private encodeBool(arg: boolean): string {\r\n    if (typeof arg !== 'boolean') {\r\n      throw new Error(`Argument ${arg} should be a boolean`);\r\n    }\r\n    return arg ? this.padStart('1', 64, '0') : this.padStart('0', 64, '0');\r\n  }\r\n\r\n  /***\r\n   * PadStart / PadEnd\r\n   */\r\n  private padStart(target: string, targetLength: number, padString: string): string {\r\n    /* tslint:disable */\r\n    targetLength = targetLength >> 0; //truncate if number or convert non-number to 0;\r\n    /* tslint:enable */\r\n    padString = String(typeof padString !== 'undefined' ? padString : ' ');\r\n    if (target.length > targetLength) {\r\n      return String(target);\r\n    } else {\r\n      targetLength = targetLength - target.length;\r\n      if (targetLength > padString.length) {\r\n        padString += padString.repeat(targetLength / padString.length); //append to original to ensure we are longer than needed\r\n      }\r\n      return padString.slice(0, targetLength) + String(target);\r\n    }\r\n  };\r\n\r\n  private padEnd(target: string, targetLength: number, padString: string): string{\r\n    /* tslint:disable */\r\n    targetLength = targetLength >> 0; //floor if number or convert non-number to 0;\r\n    /* tslint:enable */\r\n    padString = String(typeof padString !== 'undefined' ? padString : ' ');\r\n    if (target.length > targetLength) {\r\n      return String(target);\r\n    } else {\r\n      targetLength = targetLength - target.length;\r\n      if (targetLength > padString.length) {\r\n        padString += padString.repeat(targetLength / padString.length); //append to original to ensure we are longer than needed\r\n      }\r\n      return String(target) + padString.slice(0, targetLength);\r\n    }\r\n  };\r\n}\r\n","import { ContractModel } from '@ngeth/utils';\r\nimport { Injectable, Type } from '@angular/core';\r\nimport { ContractProvider } from '@ngeth/provider';\r\nimport { ABIEncoder, ABIDecoder } from './abi';\r\nimport { ContractModule } from './contract.module';\r\nimport { ContractClass } from './contract';\r\n\r\nexport function Contract<T extends ContractModel>(metadata: {\r\n  provider?: Type<ContractProvider>;  // TODO : Use for custom provider (with Auth)\r\n  abi: any[] | string;\r\n  addresses?: {\r\n    mainnet?: string;\r\n    ropsten?: string;\r\n    rinkeby?: string;\r\n    kovan?: string;\r\n  };\r\n}) {\r\n  const { abi, addresses } = metadata;\r\n  const jsonInterace: any[] = typeof abi === 'string' ? JSON.parse(abi) : abi;\r\n\r\n  /**\r\n   * Get the address of the contract depending on the id of the network\r\n   * @param id The id of the network\r\n   */\r\n  const getAddress = (id: number): string => {\r\n    switch(id) {\r\n      case 1: return addresses['mainnet'];\r\n      case 3: return addresses['ropsten'];\r\n      case 4: return addresses['rinkeby'];\r\n      case 42: return addresses['kovan'];\r\n      default: return addresses['mainnet'];\r\n    }\r\n  }\r\n\r\n  return function(Base) {\r\n    @Injectable({ providedIn: ContractModule })\r\n    class ContractDecorated extends ContractClass<T> {\r\n      constructor(\r\n        protected encoder: ABIEncoder,\r\n        protected decoder: ABIDecoder,\r\n        protected provider: ContractProvider\r\n      ) {\r\n        super(encoder, decoder, provider, jsonInterace, getAddress(provider.id));\r\n      }\r\n    }\r\n    return ContractDecorated as any;\r\n  };\r\n}\r\n","import { ContractClass } from '../../contract';\r\nimport { Contract } from '../../contract.decorator';\r\nimport { IEncoderTestContract } from './encoder-test.models';\r\nconst abi = require('./encoder-test.abi.json');\r\n\r\n@Contract<IEncoderTestContract>({\r\n  abi: abi,\r\n  addresses: {\r\n    ropsten: '0x344f641ff60f6308ad70b1e62052764835f48e00'\r\n  }\r\n})\r\nexport class EncoderTestContract extends ContractClass<IEncoderTestContract> {}\r\n","import { ContractClass } from '../../contract';\r\nimport { Contract,  } from '../../contract.decorator';\r\nimport { ITestEventContract } from './test-event.models';\r\nconst abi = require('./test-event.abi.json');\r\n\r\n@Contract<ITestEventContract>({\r\n  abi: abi,\r\n  addresses: {\r\n    ropsten: '0xc0D6C4cbA14aeFC218d0ff669e07D73E74078248'\r\n  }\r\n})\r\nexport class TestEventContract extends ContractClass<ITestEventContract> {}\r\n"]}